@phdthesis{eremondi_design_2023,
	title = {On the design of a gradual dependently typed language for programming},
	url = {https://doi.library.ubc.ca/10.14288/1.0428823},
	doi = {10.14288/1.0428823},
	abstract = {Dependently typed programming languages provide a way to write programs, specifications, and correctness proofs using a single language. If a dependent type checker accepts a program, the programmer can be assured that it behaves according to the specification given in its types. However, dependently typed programming languages can be hard to use. Gradual types provide a way to mix dynamically and statically typed code in a single language. Under this paradigm, programs may have imprecise types, causing certain type checks to be deferred to run time. We build the theoretical foundations for combining gradual and dependent types in a programming language, with the aim of making dependent types easier to use. The differences between these two paradigms lead to inherent tensions when choosing the properties such a language should satisfy. Gradual typing's effectful nature conflicts with the compile-time reductions of dependent type checking. Gradual run-time type comparisons clash with dependent types containing terms that bind variables. This dissertation identifies such tensions and proposes a design that finds balance between the conflicting goals. Our contribution has three parts: First, we present a foundational calculus for gradual dependent types, with functions, function types and universes. To ensure that type checking terminates, we reduce compile-time terms with approximate normalization, producing imprecise results when the available type information cannot guarantee termination. We use hereditary substitution to show that approximate normalization always terminates. Second, we present a notion of propositional equality for gradual dependent types. We devise a method of tracking run-time consistency information between imprecise equated terms, and introduce a composition operator in the language itself. Third, we show that the first and second contributions can be combined, giving a language with approximate normalization that supports inductive types and propositional equality with dynamic consistency tracking. Since hereditary substitution does not scale to inductive types, we use a syntactic model to establish termination. The same technique is used to model non-terminating run-time semantics using guarded type theory, paving the road for mechanizing the metatheory of gradual dependent types.},
	author = {Eremondi, Joseph S.},
	editora = {University Of British Columbia},
	school = {University Of British Columbia},
	editoratype = {collaborator},
	urldate = {2024-08-21},
	date = {2023},
	year = {2023},
	langid = {english},
	keywords = {Dependent Types, Gradual Typing, Qualifying Exam},
	file = {ubc_2023_may_eremondi_joseph.pdf:/home/celebrimbor/Zotero/storage/E9S4GIWR/ubc_2023_may_eremondi_joseph.pdf:application/pdf},
}

@article{lennon-bertrand_gradualizing_2022,
	title = {Gradualizing the Calculus of Inductive Constructions},
	volume = {44},
	issn = {0164-0925, 1558-4593},
	url = {https://dl.acm.org/doi/10.1145/3495528},
	doi = {10.1145/3495528},
	abstract = {We investigate gradual variations on the Calculus of Inductive Construction ({CIC}) for swifter prototyping with imprecise types and terms. We observe, with a no-go theorem, a crucial trade-off between graduality and the key properties of normalization and closure of universes under dependent product that {CIC} enjoys. Beyond this Fire Triangle of Graduality, we explore the gradualization of {CIC} with three different compromises, each relaxing one edge of the Fire Triangle. We develop a parametrized presentation of Gradual {CIC} ({GCIC}) that encompasses all three variations, and develop their metatheory. We first present a bidirectional elaboration of {GCIC} to a dependently-typed cast calculus, {CastCIC}, which elucidates the interrelation between typing, conversion, and the gradual guarantees. We use a syntactic model of {CastCIC} to inform the design of a safe, confluent reduction, and establish, when applicable, normalization. We study the static and dynamic gradual guarantees as well as the stronger notion of graduality with embedding-projection pairs formulated by New and Ahmed, using appropriate semantic model constructions. This work informs and paves the way towards the development of malleable proof assistants and dependently-typed programming languages.},
	pages = {1--82},
	number = {2},
	journal = {{ACM} Transactions on Programming Languages and Systems},
	shortjournal = {{ACM} Trans. Program. Lang. Syst.},
	author = {Lennon-Bertrand, Meven and Maillard, Kenji and Tabareau, Nicolas and Tanter, \'Eric},
	urldate = {2024-09-17},
	date = {2022-06-30},
	year = {2022},
	langid = {english},
	keywords = {Dependent Types, Gradual Typing, Qualifying Exam},
	file = {3495528.pdf:/home/celebrimbor/Zotero/storage/5DYED22P/3495528.pdf:application/pdf},
}

@article{malewski_gradual_2024,
	title = {Gradual Indexed Inductive Types},
	volume = {8},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3674644},
	doi = {10.1145/3674644},
	abstract = {Indexed inductive types are essential in dependently-typed programming languages, enabling precise and expressive specifications of data structures and properties. Recognizing that programming and proving with dependent types could benefit from the smooth integration of static and dynamic checking that gradual typing offers, recent efforts have studied gradual dependent types. Gradualizing indexed inductive types however remains mostly unexplored: the standard encodings of indexed inductive types in intensional type theory, e.g., using type-level fixpoints or subset types, break in the presence of gradual features; and previous work on gradual dependent types focus on very specific instances of indexed inductive types. This paper contributes a general framework, named {PUNK}, specifically designed for exploring the design space of gradual indexed inductive types. {PUNK} is a versatile framework, enabling the exploration of the space between eager and lazy cast reduction semantics that arise from the interaction between casts and the inductive eliminator, allowing them to coexist and interoperate in a single system. Our work provides significant insights into the intersection of dependent types and gradual typing, by proposing a criteria for well-behaved gradual indexed inductive types, systematically addressing the outlined challenges of integrating these types. The contributions of this paper are a step forward in the quest for making gradual theorem proving and gradual dependently-typed programming a reality.},
	pages = {544--572},
	issue = {{ICFP}},
	journal = {Proceedings of the {ACM} on Programming Languages},
	shortjournal = {Proc. {ACM} Program. Lang.},
	author = {Malewski, Mara and Maillard, Kenji and Tabareau, Nicolas and Tanter, \'Eric},
	urldate = {2024-10-02},
	date = {2024-08-15},
	year = {2024},
	langid = {english},
	keywords = {Dependent Types, Gradual Typing, Qualifying Exam},
	file = {3674644.pdf:/home/celebrimbor/Zotero/storage/MPIWRYFW/3674644.pdf:application/pdf},
}

@inproceedings{shi_partial_2023,
	location = {Cascais Portugal},
	title = {Partial Gradual Dependent Type Theory},
	isbn = {9798400703843},
	url = {https://dl.acm.org/doi/10.1145/3618305.3623594},
	doi = {10.1145/3618305.3623594},
	eventtitle = {{SPLASH} '23: 2023 {ACM} {SIGPLAN} International Conference on Systems, Programming, Languages, and Applications: Software for Humanity},
	booktitle = {{SPLASH} '23: 2023 {ACM} {SIGPLAN} International Conference on Systems, Programming, Languages, and Applications: Software for Humanity},
	pages = {22--24},
	publisher = {{ACM}},
	author = {Shi, Zhan},
	urldate = {2024-10-02},
	date = {2023-10-22},
	year = {2023},
	langid = {english},
	keywords = {Dependent Types, Gradual Typing, Qualifying Exam},
	file = {3618305.3623594.pdf:/home/celebrimbor/Zotero/storage/XMU657TQ/3618305.3623594.pdf:application/pdf},
}

@article{eremondi_propositional_2022,
	title = {Propositional equality for gradual dependently typed programming},
	volume = {6},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3547627},
	doi = {10.1145/3547627},
	abstract = {Gradual dependent types can help with the incremental adoption of dependently typed code by providing a principled semantics for
              imprecise
              types and proofs, where some parts have been omitted. Current theories of gradual dependent types, though, lack a central feature of type theory: propositional equality. Lennon-Bertrand et al. show that, when the reflexive proof
              refl
              is the only closed value of an equality type, a gradual extension of the Calculus of Inductive Constructions ({CIC}) with propositional equality violates static observational equivalences. Extensionally-equal functions should be indistinguishable at run time, but they can be distinguished using a combination of equality and type imprecision.


              This work presents a gradual dependently typed language that supports propositional equality. We avoid the above issues by devising an equality type of which
              refl
              is not the only closed inhabitant. Instead, each equality proof is accompanied by a term that is at least as precise as the equated terms, acting as a witness of their plausible equality. These witnesses track partial type information as a program runs, raising errors when that information shows that two equated terms are undeniably inconsistent. Composition of type information is internalized as a construct of the language, and is deferred for function bodies whose evaluation is blocked by variables. We thus ensure that extensionally-equal functions compose without error, thereby preventing contexts from distinguishing them. We describe the challenges of designing consistency and precision relations for this system, along with solutions to these challenges. Finally, we prove important metatheory: type safety, conservative embedding of {CIC}, weak canonicity, and the gradual guarantees of Siek et al., which ensure that reducing a program‚Äôs precision introduces no new static or dynamic errors.},
	pages = {165--193},
	issue = {{ICFP}},
	journal = {Proceedings of the {ACM} on Programming Languages},
	shortjournal = {Proc. {ACM} Program. Lang.},
	author = {Eremondi, Joseph and Garcia, Ronald and Tanter, \'Eric},
	urldate = {2024-10-02},
	date = {2022-08-29},
	year = {2022},
	langid = {english},
	keywords = {Dependent Types, Gradual Typing, Qualifying Exam},
	file = {3547627.pdf:/home/celebrimbor/Zotero/storage/QP5ZLJUP/3547627.pdf:application/pdf},
}

@article{maillard_reasonably_2022,
	title = {A reasonably gradual type theory},
	volume = {6},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3547655},
	doi = {10.1145/3547655},
	abstract = {Gradualizing the Calculus of Inductive Constructions ({CIC}) involves dealing with subtle tensions between normalization, graduality, and conservativity with respect to {CIC}. Recently, {GCIC} has been proposed as a parametrized gradual type theory that admits three variants, each sacrificing one of these properties. For devising a gradual proof assistant based on {CIC}, normalization and conservativity with respect to {CIC} are key, but the tension with graduality needs to be addressed. Additionally, several challenges remain:
(1) The presence of two wildcard terms at any type---the error and unknown terms---enables trivial proofs of any theorem, jeopardizing the use of a gradual type theory in a proof assistant;
(2) Supporting general indexed inductive families, most prominently equality, is an open problem;
(3) Theoretical accounts of gradual typing and graduality so far do not support handling type mismatches detected during reduction;
(4) Precision and graduality are external notions not amenable to reasoning within a gradual type theory.
All these issues manifest primally in {CastCIC}, the cast calculus used to define {GCIC}. In this work, we present an extension of {CastCIC} called {GRIP}. {GRIP} is a reasonably gradual type theory that addresses the issues above, featuring internal precision and general exception handling. By adopting a novel interpretation of the unknown term that carefully accounts for universe levels, {GRIP} satisfies graduality for a large and well-defined class of terms, in addition to being normalizing and a conservative extension of {CIC}. Internal precision supports reasoning about graduality within {GRIP} itself, for instance to characterize gradual exception-handling terms, and supports gradual subset types. We develop the metatheory of {GRIP} using a model formalized in Coq, and provide a prototype implementation of {GRIP} in Agda.},
	pages = {931--959},
	issue = {{ICFP}},
	journal = {Proceedings of the {ACM} on Programming Languages},
	shortjournal = {Proc. {ACM} Program. Lang.},
	author = {Maillard, Kenji and Lennon-Bertrand, Meven and Tabareau, Nicolas and Tanter, \'Eric},
	urldate = {2024-10-02},
	date = {2022-08-29},
	year = {2022},
	langid = {english},
	keywords = {Dependent Types, Gradual Typing, Qualifying Exam},
	file = {3547655.pdf:/home/celebrimbor/Zotero/storage/NQNQY5F9/3547655.pdf:application/pdf},
}

@article{eremondi_approximate_2019,
	title = {Approximate normalization for gradual dependent types},
	volume = {3},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3341692},
	doi = {10.1145/3341692},
	abstract = {Dependent types help programmers write highly reliable code. However, this reliability comes at a cost: it can be challenging to write new prototypes in (or migrate old code to) dependently-typed programming languages. Gradual typing makes static type disciplines more flexible, so an appropriate notion of gradual dependent types could fruitfully lower this cost. However, dependent types raise unique challenges for gradual typing. Dependent typechecking involves the execution of program code, but gradually-typed code can signal runtime type errors or diverge. These runtime errors threaten the soundness guarantees that make dependent types so attractive, while divergence spoils the type-driven programming experience.

              This paper presents {GDTL}, a gradual dependently-typed language that emphasizes pragmatic dependently-typed programming. {GDTL} fully embeds both an untyped and dependently-typed language, and allows for smooth transitions between the two. In addition to gradual types we introduce
              gradual terms
              , which allow the user to be imprecise in type indices and to omit proof terms; runtime checks ensure type safety. To account for nontermination and failure, we distinguish between compile-time normalization and run-time execution: compile-time normalization is
              approximate
              but total, while runtime execution is
              exact
              , but may fail or diverge. We prove that {GDTL} has decidable typechecking and satisfies all the expected properties of gradual languages. In particular, {GDTL} satisfies the static and dynamic gradual guarantees: reducing type precision preserves typedness, and altering type precision does not change program behavior outside of dynamic type failures. To prove these properties, we were led to establish a novel
              normalization gradual guarantee
              that captures the monotonicity of approximate normalization with respect to imprecision.},
	pages = {1--30},
	issue = {{ICFP}},
	journal = {Proceedings of the {ACM} on Programming Languages},
	shortjournal = {Proc. {ACM} Program. Lang.},
	author = {Eremondi, Joseph and Tanter, \'Eric and Garcia, Ronald},
	urldate = {2024-10-02},
	date = {2019-07-26},
	year = {2019},
	langid = {english},
	keywords = {Dependent Types, Gradual Typing, Qualifying Exam},
	file = {3341692.pdf:/home/celebrimbor/Zotero/storage/RF586MMJ/3341692.pdf:application/pdf},
}

@article{siek_gradual_2006,
	title = {Gradual Typing for Functional Languages},
	abstract = {Static and dynamic type systems have well-known strengths and weaknesses, and each is better suited for different programming tasks. There have been many efforts to integrate static and dynamic typing and thereby combine the beneÔ¨Åts of both typing disciplines in the same language. The Ô¨Çexibility of static typing can be improved by adding a type Dynamic and a typecase form. The safety and performance of dynamic typing can be improved by adding optional type annotations or by performing type inference (as in soft typing). However, there has been little formal work on type systems that allow a programmer-controlled migration between dynamic and static typing. Thatte proposed Quasi-Static Typing, but it does not statically catch all type errors in completely annotated programs. Anderson and Drossopoulou deÔ¨Åned a nominal type system for an object-oriented language with optional type annotations. However, developing a sound, gradual type system for functional languages with structural types is an open problem.},
	journal = {Proceedings of the 2006 Scheme and Functional Programming Workshop},
	author = {Siek, Jeremy G and Taha, Walid},
	year = {2006},
	langid = {english},
	file = {Siek and Taha - 2006 - Gradual Typing for Functional Languages.pdf:/home/celebrimbor/Zotero/storage/LK6GIWWU/Siek and Taha - 2006 - Gradual Typing for Functional Languages.pdf:application/pdf},
}

@inproceedings{sergey_gradual_2012,
	location = {Berlin, Heidelberg},
	title = {Gradual Ownership Types},
	isbn = {978-3-642-28869-2},
	abstract = {Gradual Ownership Types are a framework allowing programs to be partially annotated with ownership types, while providing the same encapsulation guarantees. The formalism provides a static guarantee of the desired encapsulation property for fully annotated programs, and dynamic guarantees for partially annotated programs via dynamic checks inserted by the compiler. This enables a smooth migration from ownership-unaware to ownership-typed code.},
	pages = {579--599},
	booktitle = {Programming Languages and Systems},
	publisher = {Springer Berlin Heidelberg},
	author = {Sergey, Ilya and Clarke, Dave},
	editor = {Seidl, Helmut},
	date = {2012},
	year = {2012},
}

@inproceedings{lehmann_gradual_2017,
	location = {Paris France},
	title = {Gradual refinement types},
	isbn = {978-1-4503-4660-3},
	url = {https://dl.acm.org/doi/10.1145/3009837.3009856},
	doi = {10.1145/3009837.3009856},
	abstract = {ReÔ¨Ånement types are an effective language-based veriÔ¨Åcation technique. However, as any expressive typing discipline, its strength is its weakness, imposing sometimes undesired rigidity. Guided by abstract interpretation, we extend the gradual typing agenda and develop the notion of gradual reÔ¨Ånement types, allowing smooth evolution and interoperability between simple types and logicallyreÔ¨Åned types. In doing so, we address two challenges unexplored in the gradual typing literature: dealing with imprecise logical information, and with dependent function types. The Ô¨Årst challenge leads to a crucial notion of locality for reÔ¨Ånement formulas, and the second yields novel operators related to type- and term-level substitution, identifying new opportunity for runtime errors in gradual dependently-typed languages. The gradual language we present is type safe, type sound, and satisÔ¨Åes the reÔ¨Åned criteria for graduallytyped languages of Siek et al. We also explain how to extend our approach to richer reÔ¨Ånement logics, anticipating key challenges to consider.},
	eventtitle = {{POPL} '17: The 44th Annual {ACM} {SIGPLAN} Symposium on Principles of Programming Languages},
	pages = {775--788},
	booktitle = {Proceedings of the 44th {ACM} {SIGPLAN} Symposium on Principles of Programming Languages},
	publisher = {{ACM}},
	author = {Lehmann, Nico and Tanter, \'Eric},
	urldate = {2025-02-10},
	date = {2017-01},
	year = {2017},
	langid = {english},
	keywords = {Gradual Typing},
	file = {Lehmann and Tanter - 2017 - Gradual refinement types.pdf:/home/celebrimbor/Zotero/storage/43DUVY5F/Lehmann and Tanter - 2017 - Gradual refinement types.pdf:application/pdf},
}

@inproceedings{fennell_gradual_2013,
	location = {New Orleans, {LA}},
	title = {Gradual Security Typing with References},
	isbn = {978-0-7695-5031-2},
	url = {https://ieeexplore.ieee.org/document/6595831/},
	doi = {10.1109/CSF.2013.22},
	eventtitle = {2013 {IEEE} 26th Computer Security Foundations Symposium ({CSF})},
	pages = {224--239},
	booktitle = {2013 {IEEE} 26th Computer Security Foundations Symposium},
	publisher = {{IEEE}},
	author = {Fennell, Luminous and Thiemann, Peter},
	urldate = {2025-02-10},
	date = {2013-06},
	year = {2013},
}

@article{toro_type-driven_2018,
	title = {Type-Driven Gradual Security with References},
	volume = {40},
	issn = {0164-0925, 1558-4593},
	url = {https://dl.acm.org/doi/10.1145/3229061},
	doi = {10.1145/3229061},
	abstract = {In security-typed programming languages, types statically enforce noninterference between potentially conspiring values, such as the arguments and results of functions. But to adopt static security types, like other advanced type disciplines, programmers face a steep wholesale transition, often forcing them to refactor working code just to satisfy their type checker. To provide a gentler path to security typing that supports safe and stylish but hard-to-verify programming idioms, researchers have designed languages that blend static and dynamic checking of security types. Unfortunately, most of the resulting languages only support static, type-based reasoning about noninterference if a program is entirely statically secured. This limitation substantially weakens the benefits that dynamic enforcement brings to static security typing. Additionally, current proposals are focused on languages with explicit casts and therefore do not fulfill the vision of gradual typing, according to which the boundaries between static and dynamic checking only arise from the (im)precision of type annotations and are transparently mediated by implicit checks.

              In this article, we present {GSL}
              Ref
              , a gradual security-typed higher-order language with references. As a gradual language, {GSL}
              Ref
              supports the range of static-to-dynamic security checking exclusively driven by type annotations, without resorting to explicit casts. Additionally, {GSL}
              Ref
              lets programmers use types to reason statically about termination-insensitive noninterference in
              all
              programs, even those that enforce security dynamically. We prove that {GSL}
              Ref
              satisfies all but one of Siek et al.‚Äôs criteria for gradually-typed languages, which ensure that programs can seamlessly transition between simple typing and security typing. A notable exception regards the dynamic gradual guarantee, which some specific programs must violate if they are to satisfy noninterference; it remains an open question whether such a language could fully satisfy the dynamic gradual guarantee. To realize this design, we were led to draw a sharp distinction between syntactic type
              safety
              and semantic type
              soundness
              , each of which constrains the design of the gradual language.},
	pages = {1--55},
	number = {4},
	journaltitle = {{ACM} Transactions on Programming Languages and Systems},
	journal = {{ACM} Transactions on Programming Languages and Systems},
	shortjournal = {{ACM} Trans. Program. Lang. Syst.},
	author = {Toro, Mat√≠as and Garcia, Ronald and Tanter, \'Eric},
	urldate = {2025-02-10},
	date = {2018-12-31},
	year = {2018},
	langid = {english},
	keywords = {Gradual Typing},
	file = {Toro et al. - 2018 - Type-Driven Gradual Security with References.pdf:/home/celebrimbor/Zotero/storage/VQHKRUG8/Toro et al. - 2018 - Type-Driven Gradual Security with References.pdf:application/pdf},
}

@article{chen_quest_2024,
	title = {Quest Complete: The Holy Grail of Gradual Security},
	volume = {8},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3656442},
	doi = {10.1145/3656442},
	shorttitle = {Quest Complete},
	abstract = {Languages with gradual information-flow control combine static and dynamic techniques to prevent security leaks. Gradual languages should satisfy the gradual guarantee: programs that only differ in the precision of their type annotations should behave the same modulo cast errors. Unfortunately, Toro et al. [2018] identify a tension between the gradual guarantee and information security; they were unable to satisfy both properties in the language {GSLRef} and had to settle for only satisfying information-flow security. Azevedo de Amorim et al. [2020] show that by sacrificing type-guided classification, one obtains a language that satisfies both noninterference and the gradual guarantee. Bichhawat et al. [2021] show that both properties can be satisfied by sacrificing the no-sensitive-upgrade mechanism, replacing it with a static analysis.

In this paper we present a language design, ùúÜ‚òÖ{IFC}, that satisfies both noninterference and the gradual guarantee without making any sacrifices. We keep the type-guided classification of {GSLRef} and use the standard no-sensitive-upgrade mechanism to prevent implicit flows through mutable references. The key to the design of ùúÜ‚òÖ{IFC} is to walk back the decision in {GSLRef} to include the unknown label ‚òÖ among the runtime security labels. We give a formal definition of ùúÜ‚òÖ{IFC}, prove the gradual guarantee, and prove noninterference. Of technical note, the semantics of ùúÜ‚òÖ{IFC} is the first gradual information-flow control language to be specified using coercion calculi (a la Henglein), thereby expanding the coercion-based theory of gradual typing.},
	pages = {1609--1632},
	issue = {{PLDI}},
	journaltitle = {Proceedings of the {ACM} on Programming Languages},
	journal = {Proceedings of the {ACM} on Programming Languages},
	shortjournal = {Proc. {ACM} Program. Lang.},
	author = {Chen, Tianyu and Siek, Jeremy G.},
	urldate = {2025-02-10},
	date = {2024-06-20},
	year = {2024},
	langid = {english},
	file = {Chen and Siek - 2024 - Quest Complete The Holy Grail of Gradual Security.pdf:/home/celebrimbor/Zotero/storage/MXVRX6MS/Chen and Siek - 2024 - Quest Complete The Holy Grail of Gradual Security.pdf:application/pdf},
}

@article{igarashi_gradual_2017,
	title = {Gradual session types},
	volume = {1},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3110282},
	doi = {10.1145/3110282},
	abstract = {Session types are a rich type discipline, based on linear types, that lift the sort of safety claims that come with type systems to communications. However, web-based applications and micro services are often written in a mix of languages, with type disciplines in a spectrum between static and dynamic typing. Gradual session types address this mixed setting by providing a framework which grants seamless transition between statically typed handling of sessions and any required degree of dynamic typing.
            We propose {GradualGV} as an extension of the functional session type system {GV} with dynamic types and casts. We demonstrate type and communication safety as well as blame safety, thus extending previous results to functional languages with session-based communication. The interplay of linearity and dynamic types requires a novel approach to specifying the dynamics of the language.},
	pages = {1--28},
	issue = {{ICFP}},
	journaltitle = {Proceedings of the {ACM} on Programming Languages},
	journal = {Proceedings of the {ACM} on Programming Languages},
	shortjournal = {Proc. {ACM} Program. Lang.},
	author = {Igarashi, Atsushi and Thiemann, Peter and Vasconcelos, Vasco T. and Wadler, Philip},
	urldate = {2025-02-10},
	date = {2017-08-29},
	year = {2017},
	langid = {english},
	keywords = {Gradual Typing},
	file = {Full Text:/home/celebrimbor/Zotero/storage/S5WFYW53/Igarashi et al. - 2017 - Gradual session types.pdf:application/pdf},
}
@book{martin-lof_intuitionistic_1984,
	Author = {Martin-L{\"o}f, Per},
	Isbn = {88-7088-105-9},
	Mrclass = {03B15 (03F50 03F55)},
	Mrnumber = {769301 (86j:03005)},
	Mrreviewer = {M. M. Richter},
	Pages = {iv+91},
	Publisher = {Bibliopolis},
	Series = {Studies in Proof Theory},
	Subtitle = {Notes by Giovanni Sambin},
	Title = {Intuitionistic type theory},
	Volume = {1},
	Year = {1984}}

@article{coquand_calculus_1988,
	title = {The calculus of constructions},
	volume = {76},
	rights = {https://www.elsevier.com/tdm/userlicense/1.0/},
	issn = {08905401},
	url = {https://linkinghub.elsevier.com/retrieve/pii/0890540188900053},
	doi = {10.1016/0890-5401(88)90005-3},
	pages = {95--120},
	number = {2},
	journaltitle = {Information and Computation},
	journal = {Information and Computation},
	shortjournal = {Information and Computation},
	author = {Coquand, Thierry and Huet, G√©rard},
	urldate = {2025-02-10},
	date = {1988-02},
	year = {1988},
	langid = {english},
	keywords = {Dependent Types},
}

@article{siek_refined_2015,
	title = {Refined Criteria for Gradual Typing},
	volume = {32},
	rights = {Creative Commons Attribution 3.0 Unported license, info:eu-repo/semantics/{openAccess}},
	issn = {1868-8969},
	url = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.SNAPL.2015.274},
	doi = {10.4230/LIPICS.SNAPL.2015.274},
	abstract = {Siek and Taha [2006] coined the term gradual typing to describe a theory for integrating static and dynamic typing within a single language that 1) puts the programmer in control of which regions of code are statically or dynamically typed and 2) enables the gradual evolution of code between the two typing disciplines. Since 2006, the term gradual typing has become quite popular but its meaning has become diluted to encompass anything related to the integration of static and dynamic typing. This dilution is partly the fault of the original paper, which provided an incomplete formal characterization of what it means to be gradually typed. In this paper we draw a crisp line in the sand that includes a new formal property, named the gradual guarantee, that relates the behavior of programs that differ only with respect to their type annotations.  We argue that the gradual guarantee provides important guidance for designers of gradually typed languages. We survey the gradual typing literature, critiquing designs in light of the gradual guarantee. We also report on a mechanized proof that the gradual guarantee holds for the Gradually Typed Lambda Calculus.},
	pages = {274--293},
	journaltitle = {{LIPIcs}, Volume 32, {SNAPL} 2015},
	journal = {{LIPIcs}, Volume 32, {SNAPL} 2015},
	author = {Siek, Jeremy G. and Vitousek, Michael M. and Cimini, Matteo and Boyland, John Tang},
	editora = {Ball, Thomas and Bodik, Rastislav and Krishnamurthi, Shriram and Lerner, Benjamin S. and Morrisett, Greg},
	editoratype = {collaborator},
	urldate = {2024-09-04},
	date = {2015},
	year = {2015},
	langid = {english},
	keywords = {Gradual Typing},
	file = {LIPIcs.SNAPL.2015.274.pdf:/home/celebrimbor/Zotero/storage/H8AKIMZA/LIPIcs.SNAPL.2015.274.pdf:application/pdf},
}

@article{new_graduality_2018,
	title = {Graduality from embedding-projection pairs},
	volume = {2},
	url = {https://dl.acm.org/doi/10.1145/3236768},
	doi = {10.1145/3236768},
	abstract = {Gradually typed languages allow statically typed and dynamically typed code to interact while maintaining benefits of both styles. The key to reasoning about these mixed programs is Siek-Vitousek-Cimini-Boyland‚Äôs (dynamic) gradual guarantee, which says that giving components of a program more precise types only adds runtime type checking, and does not otherwise change behavior. In this paper, we give a semantic reformulation of the gradual guarantee called graduality. We change the name to promote the analogy that graduality is to gradual typing what parametricity is to polymorphism. Each gives a local-to-global, syntactic-to-semantic reasoning principle that is formulated in terms of a kind of observational approximation. Utilizing the analogy, we develop a novel logical relation for proving graduality. We show that embedding-projection pairs (ep pairs) are to graduality what relations are to parametricity. We argue that casts between two types where one is ‚Äúmore dynamic‚Äù (less precise) than the other necessarily form an ep pair, and we use this to cleanly prove the graduality cases for casts from the ep-pair property. To construct ep pairs, we give an analysis of the type dynamism relation‚Äîalso known as type precision or na√Øve subtyping‚Äîthat interprets the rules for type dynamism as compositional constructions on ep pairs, analogous to the coercion interpretation of subtyping.},
	pages = {73:1--73:30},
	issue = {{ICFP}},
	journaltitle = {Proc. {ACM} Program. Lang.},
	journal = {Proc. {ACM} Program. Lang.},
	author = {New, Max S. and Ahmed, Amal},
	urldate = {2024-09-18},
	date = {2018-07-30},
	year = {2018},
	keywords = {Gradual Typing},
	file = {Full Text PDF:/home/celebrimbor/Zotero/storage/E3CBRIIF/New and Ahmed - 2018 - Graduality from embedding-projection pairs.pdf:application/pdf},
}

@incollection{siek_exploring_2009,
	location = {Berlin, Heidelberg},
	title = {Exploring the Design Space of Higher-Order Casts},
	volume = {5502},
	rights = {http://www.springer.com/tdm},
	isbn = {978-3-642-00589-3 978-3-642-00590-9},
	url = {http://link.springer.com/10.1007/978-3-642-00590-9_2},
	pages = {17--31},
	booktitle = {Programming Languages and Systems},
	publisher = {Springer Berlin Heidelberg},
	author = {Siek, Jeremy and Garcia, Ronald and Taha, Walid},
	editor = {Castagna, Giuseppe},
	urldate = {2025-02-11},
	date = {2009},
	year = {2009},
	doi = {10.1007/978-3-642-00590-9_2},
	note = {Series Title: Lecture Notes in Computer Science},
	file = {Full Text:/home/celebrimbor/Zotero/storage/7RK66QXF/Siek et al. - 2009 - Exploring the Design Space of Higher-Order Casts.pdf:application/pdf},
}

@inproceedings{garcia_abstracting_2016,
	location = {St. Petersburg {FL} {USA}},
	title = {Abstracting gradual typing},
	booktitle = {Abstracting gradual typing},
	isbn = {978-1-4503-3549-2},
	url = {https://dl.acm.org/doi/10.1145/2837614.2837670},
	doi = {10.1145/2837614.2837670},
	eventtitle = {{POPL} '16: The 43rd Annual {ACM} {SIGPLAN}-{SIGACT} Symposium on Principles of Programming Languages},
	pages = {429--442},
	publisher = {{ACM}},
	author = {Garcia, Ronald and Clark, Alison M. and Tanter, \'Eric},
	urldate = {2024-09-03},
	date = {2016-01-11},
	year = {2016},
	langid = {english},
	keywords = {Gradual Typing},
	file = {abstracting-gradual-typing .pdf:/home/celebrimbor/Zotero/storage/VSJNRPUS/abstracting-gradual-typing .pdf:application/pdf},
}

@incollection{pedrot_failure_2018,
	location = {Cham},
	title = {Failure is Not an Option},
	volume = {10801},
	isbn = {978-3-319-89883-4 978-3-319-89884-1},
	url = {http://link.springer.com/10.1007/978-3-319-89884-1_9},
	pages = {245--271},
	booktitle = {Programming Languages and Systems},
	publisher = {Springer International Publishing},
	author = {P\'edrot, Pierre-Marie and Tabareau, Nicolas},
	editor = {Ahmed, Amal},
	urldate = {2025-02-25},
	date = {2018},
	year = {2018},
	doi = {10.1007/978-3-319-89884-1_9},
	note = {Series Title: Lecture Notes in Computer Science},
	file = {Full Text:/home/celebrimbor/Zotero/storage/3JMUUIJK/P√©drot and Tabareau - 2018 - Failure is Not an Option.pdf:application/pdf},
}

@article{harper_type_1991,
	title = {Type checking with universes},
	volume = {89},
	rights = {https://www.elsevier.com/tdm/userlicense/1.0/},
	issn = {03043975},
	url = {https://linkinghub.elsevier.com/retrieve/pii/030439759090108T},
	doi = {10.1016/0304-3975(90)90108-T},
	pages = {107--136},
	number = {1},
	journaltitle = {Theoretical Computer Science},
	journal = {Theoretical Computer Science},
	shortjournal = {Theoretical Computer Science},
	author = {Harper, Robert and Pollack, Robert},
	urldate = {2025-03-03},
	date = {1991-10},
	year = {1991},
	langid = {english},
}

@article{chargueraud_locally_2012,
	title = {The Locally Nameless Representation},
	volume = {49},
	rights = {http://www.springer.com/tdm},
	issn = {0168-7433, 1573-0670},
	url = {http://link.springer.com/10.1007/s10817-011-9225-2},
	doi = {10.1007/s10817-011-9225-2},
	pages = {363--408},
	number = {3},
	journaltitle = {Journal of Automated Reasoning},
	journal = {Journal of Automated Reasoning},
	shortjournal = {J Autom Reasoning},
	author = {Chargu√©raud, Arthur},
	urldate = {2025-03-03},
	date = {2012-10},
	year = {2012},
	langid = {english},
	file = {Full Text:/home/celebrimbor/Zotero/storage/GQZB3YD5/Chargu√©raud - 2012 - The Locally Nameless Representation.pdf:application/pdf},
}

@article{danvy_refocusing_2004,
	title = {Refocusing in Reduction Semantics},
	volume = {11},
	issn = {1601-5355, 0909-0878},
	url = {https://tidsskrift.dk/brics/article/view/21851},
	doi = {10.7146/brics.v11i26.21851},
	abstract = {The evaluation function of a reduction semantics (i.e., a small-step operational semantics with an explicit representation of the reduction context) is canonically deÔ¨Åned as the transitive closure of (1) decomposing a term into a reduction context and a redex, (2) contracting this redex, and (3) plugging the contractum in the context. Directly implementing this evaluation function therefore yields an interpreter with a worst-case overhead, for each step, that is linear in the size of the input term.},
	number = {26},
	journaltitle = {{BRICS} Report Series},
	journal = {{BRICS} Report Series},
	shortjournal = {{BRICS}},
	author = {Danvy, Olivier and Nielsen, Lasse R.},
	urldate = {2025-01-27},
	date = {2004-11-11},
	year = {2004},
	langid = {english},
	file = {Danvy and Nielsen - 2004 - Refocusing in Reduction Semantics.pdf:/home/celebrimbor/Zotero/storage/ZFL2KNFU/Danvy and Nielsen - 2004 - Refocusing in Reduction Semantics.pdf:application/pdf},
}
