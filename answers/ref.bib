@phdthesis{eremondi_design_2023,
	title = {On the design of a gradual dependently typed language for programming},
	url = {https://doi.library.ubc.ca/10.14288/1.0428823},
	doi = {10.14288/1.0428823},
	abstract = {Dependently typed programming languages provide a way to write programs, specifications, and correctness proofs using a single language. If a dependent type checker accepts a program, the programmer can be assured that it behaves according to the specification given in its types. However, dependently typed programming languages can be hard to use. Gradual types provide a way to mix dynamically and statically typed code in a single language. Under this paradigm, programs may have imprecise types, causing certain type checks to be deferred to run time. We build the theoretical foundations for combining gradual and dependent types in a programming language, with the aim of making dependent types easier to use. The differences between these two paradigms lead to inherent tensions when choosing the properties such a language should satisfy. Gradual typing's effectful nature conflicts with the compile-time reductions of dependent type checking. Gradual run-time type comparisons clash with dependent types containing terms that bind variables. This dissertation identifies such tensions and proposes a design that finds balance between the conflicting goals. Our contribution has three parts: First, we present a foundational calculus for gradual dependent types, with functions, function types and universes. To ensure that type checking terminates, we reduce compile-time terms with approximate normalization, producing imprecise results when the available type information cannot guarantee termination. We use hereditary substitution to show that approximate normalization always terminates. Second, we present a notion of propositional equality for gradual dependent types. We devise a method of tracking run-time consistency information between imprecise equated terms, and introduce a composition operator in the language itself. Third, we show that the first and second contributions can be combined, giving a language with approximate normalization that supports inductive types and propositional equality with dynamic consistency tracking. Since hereditary substitution does not scale to inductive types, we use a syntactic model to establish termination. The same technique is used to model non-terminating run-time semantics using guarded type theory, paving the road for mechanizing the metatheory of gradual dependent types.},
	author = {Eremondi, Joseph S.},
	editora = {University Of British Columbia},
	school = {University Of British Columbia},
	editoratype = {collaborator},
	urldate = {2024-08-21},
	date = {2023},
	year = {2023},
	langid = {english},
	keywords = {Dependent Types, Gradual Typing, Qualifying Exam},
	file = {ubc_2023_may_eremondi_joseph.pdf:/home/celebrimbor/Zotero/storage/E9S4GIWR/ubc_2023_may_eremondi_joseph.pdf:application/pdf},
}

@article{lennon-bertrand_gradualizing_2022,
	title = {Gradualizing the Calculus of Inductive Constructions},
	volume = {44},
	issn = {0164-0925, 1558-4593},
	url = {https://dl.acm.org/doi/10.1145/3495528},
	doi = {10.1145/3495528},
	abstract = {We investigate gradual variations on the Calculus of Inductive Construction ({CIC}) for swifter prototyping with imprecise types and terms. We observe, with a no-go theorem, a crucial trade-off between graduality and the key properties of normalization and closure of universes under dependent product that {CIC} enjoys. Beyond this Fire Triangle of Graduality, we explore the gradualization of {CIC} with three different compromises, each relaxing one edge of the Fire Triangle. We develop a parametrized presentation of Gradual {CIC} ({GCIC}) that encompasses all three variations, and develop their metatheory. We first present a bidirectional elaboration of {GCIC} to a dependently-typed cast calculus, {CastCIC}, which elucidates the interrelation between typing, conversion, and the gradual guarantees. We use a syntactic model of {CastCIC} to inform the design of a safe, confluent reduction, and establish, when applicable, normalization. We study the static and dynamic gradual guarantees as well as the stronger notion of graduality with embedding-projection pairs formulated by New and Ahmed, using appropriate semantic model constructions. This work informs and paves the way towards the development of malleable proof assistants and dependently-typed programming languages.},
	pages = {1--82},
	number = {2},
	journal = {{ACM} Transactions on Programming Languages and Systems},
	shortjournal = {{ACM} Trans. Program. Lang. Syst.},
	author = {Lennon-Bertrand, Meven and Maillard, Kenji and Tabareau, Nicolas and Tanter, \'Eric},
	urldate = {2024-09-17},
	date = {2022-06-30},
	year = {2022},
	langid = {english},
	keywords = {Dependent Types, Gradual Typing, Qualifying Exam},
	file = {3495528.pdf:/home/celebrimbor/Zotero/storage/5DYED22P/3495528.pdf:application/pdf},
}

@article{malewski_gradual_2024,
	title = {Gradual Indexed Inductive Types},
	volume = {8},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3674644},
	doi = {10.1145/3674644},
	abstract = {Indexed inductive types are essential in dependently-typed programming languages, enabling precise and expressive specifications of data structures and properties. Recognizing that programming and proving with dependent types could benefit from the smooth integration of static and dynamic checking that gradual typing offers, recent efforts have studied gradual dependent types. Gradualizing indexed inductive types however remains mostly unexplored: the standard encodings of indexed inductive types in intensional type theory, e.g., using type-level fixpoints or subset types, break in the presence of gradual features; and previous work on gradual dependent types focus on very specific instances of indexed inductive types. This paper contributes a general framework, named {PUNK}, specifically designed for exploring the design space of gradual indexed inductive types. {PUNK} is a versatile framework, enabling the exploration of the space between eager and lazy cast reduction semantics that arise from the interaction between casts and the inductive eliminator, allowing them to coexist and interoperate in a single system. Our work provides significant insights into the intersection of dependent types and gradual typing, by proposing a criteria for well-behaved gradual indexed inductive types, systematically addressing the outlined challenges of integrating these types. The contributions of this paper are a step forward in the quest for making gradual theorem proving and gradual dependently-typed programming a reality.},
	pages = {544--572},
	issue = {{ICFP}},
	journal = {Proceedings of the {ACM} on Programming Languages},
	shortjournal = {Proc. {ACM} Program. Lang.},
	author = {Malewski, Mara and Maillard, Kenji and Tabareau, Nicolas and Tanter, \'Eric},
	urldate = {2024-10-02},
	date = {2024-08-15},
	year = {2024},
	langid = {english},
	keywords = {Dependent Types, Gradual Typing, Qualifying Exam},
	file = {3674644.pdf:/home/celebrimbor/Zotero/storage/MPIWRYFW/3674644.pdf:application/pdf},
}

@inproceedings{shi_partial_2023,
	location = {Cascais Portugal},
	title = {Partial Gradual Dependent Type Theory},
	isbn = {9798400703843},
	url = {https://dl.acm.org/doi/10.1145/3618305.3623594},
	doi = {10.1145/3618305.3623594},
	eventtitle = {{SPLASH} '23: 2023 {ACM} {SIGPLAN} International Conference on Systems, Programming, Languages, and Applications: Software for Humanity},
	booktitle = {{SPLASH} '23: 2023 {ACM} {SIGPLAN} International Conference on Systems, Programming, Languages, and Applications: Software for Humanity},
	pages = {22--24},
	publisher = {{ACM}},
	author = {Shi, Zhan},
	urldate = {2024-10-02},
	date = {2023-10-22},
	year = {2023},
	langid = {english},
	keywords = {Dependent Types, Gradual Typing, Qualifying Exam},
	file = {3618305.3623594.pdf:/home/celebrimbor/Zotero/storage/XMU657TQ/3618305.3623594.pdf:application/pdf},
}

@article{eremondi_propositional_2022,
	title = {Propositional equality for gradual dependently typed programming},
	volume = {6},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3547627},
	doi = {10.1145/3547627},
	abstract = {Gradual dependent types can help with the incremental adoption of dependently typed code by providing a principled semantics for
              imprecise
              types and proofs, where some parts have been omitted. Current theories of gradual dependent types, though, lack a central feature of type theory: propositional equality. Lennon-Bertrand et al. show that, when the reflexive proof
              refl
              is the only closed value of an equality type, a gradual extension of the Calculus of Inductive Constructions ({CIC}) with propositional equality violates static observational equivalences. Extensionally-equal functions should be indistinguishable at run time, but they can be distinguished using a combination of equality and type imprecision.


              This work presents a gradual dependently typed language that supports propositional equality. We avoid the above issues by devising an equality type of which
              refl
              is not the only closed inhabitant. Instead, each equality proof is accompanied by a term that is at least as precise as the equated terms, acting as a witness of their plausible equality. These witnesses track partial type information as a program runs, raising errors when that information shows that two equated terms are undeniably inconsistent. Composition of type information is internalized as a construct of the language, and is deferred for function bodies whose evaluation is blocked by variables. We thus ensure that extensionally-equal functions compose without error, thereby preventing contexts from distinguishing them. We describe the challenges of designing consistency and precision relations for this system, along with solutions to these challenges. Finally, we prove important metatheory: type safety, conservative embedding of {CIC}, weak canonicity, and the gradual guarantees of Siek et al., which ensure that reducing a program’s precision introduces no new static or dynamic errors.},
	pages = {165--193},
	issue = {{ICFP}},
	journal = {Proceedings of the {ACM} on Programming Languages},
	shortjournal = {Proc. {ACM} Program. Lang.},
	author = {Eremondi, Joseph and Garcia, Ronald and Tanter, \'Eric},
	urldate = {2024-10-02},
	date = {2022-08-29},
	year = {2022},
	langid = {english},
	keywords = {Dependent Types, Gradual Typing, Qualifying Exam},
	file = {3547627.pdf:/home/celebrimbor/Zotero/storage/QP5ZLJUP/3547627.pdf:application/pdf},
}

@article{maillard_reasonably_2022,
	title = {A reasonably gradual type theory},
	volume = {6},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3547655},
	doi = {10.1145/3547655},
	abstract = {Gradualizing the Calculus of Inductive Constructions ({CIC}) involves dealing with subtle tensions between normalization, graduality, and conservativity with respect to {CIC}. Recently, {GCIC} has been proposed as a parametrized gradual type theory that admits three variants, each sacrificing one of these properties. For devising a gradual proof assistant based on {CIC}, normalization and conservativity with respect to {CIC} are key, but the tension with graduality needs to be addressed. Additionally, several challenges remain:
(1) The presence of two wildcard terms at any type---the error and unknown terms---enables trivial proofs of any theorem, jeopardizing the use of a gradual type theory in a proof assistant;
(2) Supporting general indexed inductive families, most prominently equality, is an open problem;
(3) Theoretical accounts of gradual typing and graduality so far do not support handling type mismatches detected during reduction;
(4) Precision and graduality are external notions not amenable to reasoning within a gradual type theory.
All these issues manifest primally in {CastCIC}, the cast calculus used to define {GCIC}. In this work, we present an extension of {CastCIC} called {GRIP}. {GRIP} is a reasonably gradual type theory that addresses the issues above, featuring internal precision and general exception handling. By adopting a novel interpretation of the unknown term that carefully accounts for universe levels, {GRIP} satisfies graduality for a large and well-defined class of terms, in addition to being normalizing and a conservative extension of {CIC}. Internal precision supports reasoning about graduality within {GRIP} itself, for instance to characterize gradual exception-handling terms, and supports gradual subset types. We develop the metatheory of {GRIP} using a model formalized in Coq, and provide a prototype implementation of {GRIP} in Agda.},
	pages = {931--959},
	issue = {{ICFP}},
	journal = {Proceedings of the {ACM} on Programming Languages},
	shortjournal = {Proc. {ACM} Program. Lang.},
	author = {Maillard, Kenji and Lennon-Bertrand, Meven and Tabareau, Nicolas and Tanter, \'Eric},
	urldate = {2024-10-02},
	date = {2022-08-29},
	year = {2022},
	langid = {english},
	keywords = {Dependent Types, Gradual Typing, Qualifying Exam},
	file = {3547655.pdf:/home/celebrimbor/Zotero/storage/NQNQY5F9/3547655.pdf:application/pdf},
}

@article{eremondi_approximate_2019,
	title = {Approximate normalization for gradual dependent types},
	volume = {3},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3341692},
	doi = {10.1145/3341692},
	abstract = {Dependent types help programmers write highly reliable code. However, this reliability comes at a cost: it can be challenging to write new prototypes in (or migrate old code to) dependently-typed programming languages. Gradual typing makes static type disciplines more flexible, so an appropriate notion of gradual dependent types could fruitfully lower this cost. However, dependent types raise unique challenges for gradual typing. Dependent typechecking involves the execution of program code, but gradually-typed code can signal runtime type errors or diverge. These runtime errors threaten the soundness guarantees that make dependent types so attractive, while divergence spoils the type-driven programming experience.

              This paper presents {GDTL}, a gradual dependently-typed language that emphasizes pragmatic dependently-typed programming. {GDTL} fully embeds both an untyped and dependently-typed language, and allows for smooth transitions between the two. In addition to gradual types we introduce
              gradual terms
              , which allow the user to be imprecise in type indices and to omit proof terms; runtime checks ensure type safety. To account for nontermination and failure, we distinguish between compile-time normalization and run-time execution: compile-time normalization is
              approximate
              but total, while runtime execution is
              exact
              , but may fail or diverge. We prove that {GDTL} has decidable typechecking and satisfies all the expected properties of gradual languages. In particular, {GDTL} satisfies the static and dynamic gradual guarantees: reducing type precision preserves typedness, and altering type precision does not change program behavior outside of dynamic type failures. To prove these properties, we were led to establish a novel
              normalization gradual guarantee
              that captures the monotonicity of approximate normalization with respect to imprecision.},
	pages = {1--30},
	issue = {{ICFP}},
	journal = {Proceedings of the {ACM} on Programming Languages},
	shortjournal = {Proc. {ACM} Program. Lang.},
	author = {Eremondi, Joseph and Tanter, \'Eric and Garcia, Ronald},
	urldate = {2024-10-02},
	date = {2019-07-26},
	year = {2019},
	langid = {english},
	keywords = {Dependent Types, Gradual Typing, Qualifying Exam},
	file = {3341692.pdf:/home/celebrimbor/Zotero/storage/RF586MMJ/3341692.pdf:application/pdf},
}

@article{siek_gradual_2006,
	title = {Gradual Typing for Functional Languages},
	abstract = {Static and dynamic type systems have well-known strengths and weaknesses, and each is better suited for different programming tasks. There have been many efforts to integrate static and dynamic typing and thereby combine the beneﬁts of both typing disciplines in the same language. The ﬂexibility of static typing can be improved by adding a type Dynamic and a typecase form. The safety and performance of dynamic typing can be improved by adding optional type annotations or by performing type inference (as in soft typing). However, there has been little formal work on type systems that allow a programmer-controlled migration between dynamic and static typing. Thatte proposed Quasi-Static Typing, but it does not statically catch all type errors in completely annotated programs. Anderson and Drossopoulou deﬁned a nominal type system for an object-oriented language with optional type annotations. However, developing a sound, gradual type system for functional languages with structural types is an open problem.},
	journal = {Proceedings of the 2006 Scheme and Functional Programming Workshop},
	author = {Siek, Jeremy G and Taha, Walid},
	year = {2006},
	langid = {english},
	file = {Siek and Taha - 2006 - Gradual Typing for Functional Languages.pdf:/home/celebrimbor/Zotero/storage/LK6GIWWU/Siek and Taha - 2006 - Gradual Typing for Functional Languages.pdf:application/pdf},
}

@inproceedings{sergey_gradual_2012,
	location = {Berlin, Heidelberg},
	title = {Gradual Ownership Types},
	isbn = {978-3-642-28869-2},
	abstract = {Gradual Ownership Types are a framework allowing programs to be partially annotated with ownership types, while providing the same encapsulation guarantees. The formalism provides a static guarantee of the desired encapsulation property for fully annotated programs, and dynamic guarantees for partially annotated programs via dynamic checks inserted by the compiler. This enables a smooth migration from ownership-unaware to ownership-typed code.},
	pages = {579--599},
	booktitle = {Programming Languages and Systems},
	publisher = {Springer Berlin Heidelberg},
	author = {Sergey, Ilya and Clarke, Dave},
	editor = {Seidl, Helmut},
	date = {2012},
	year = {2012},
}

@inproceedings{lehmann_gradual_2017,
	location = {Paris France},
	title = {Gradual refinement types},
	isbn = {978-1-4503-4660-3},
	url = {https://dl.acm.org/doi/10.1145/3009837.3009856},
	doi = {10.1145/3009837.3009856},
	abstract = {Reﬁnement types are an effective language-based veriﬁcation technique. However, as any expressive typing discipline, its strength is its weakness, imposing sometimes undesired rigidity. Guided by abstract interpretation, we extend the gradual typing agenda and develop the notion of gradual reﬁnement types, allowing smooth evolution and interoperability between simple types and logicallyreﬁned types. In doing so, we address two challenges unexplored in the gradual typing literature: dealing with imprecise logical information, and with dependent function types. The ﬁrst challenge leads to a crucial notion of locality for reﬁnement formulas, and the second yields novel operators related to type- and term-level substitution, identifying new opportunity for runtime errors in gradual dependently-typed languages. The gradual language we present is type safe, type sound, and satisﬁes the reﬁned criteria for graduallytyped languages of Siek et al. We also explain how to extend our approach to richer reﬁnement logics, anticipating key challenges to consider.},
	eventtitle = {{POPL} '17: The 44th Annual {ACM} {SIGPLAN} Symposium on Principles of Programming Languages},
	pages = {775--788},
	booktitle = {Proceedings of the 44th {ACM} {SIGPLAN} Symposium on Principles of Programming Languages},
	publisher = {{ACM}},
	author = {Lehmann, Nico and Tanter, \'Eric},
	urldate = {2025-02-10},
	date = {2017-01},
	year = {2017},
	langid = {english},
	keywords = {Gradual Typing},
	file = {Lehmann and Tanter - 2017 - Gradual refinement types.pdf:/home/celebrimbor/Zotero/storage/43DUVY5F/Lehmann and Tanter - 2017 - Gradual refinement types.pdf:application/pdf},
}

@inproceedings{fennell_gradual_2013,
	location = {New Orleans, {LA}},
	title = {Gradual Security Typing with References},
	isbn = {978-0-7695-5031-2},
	url = {https://ieeexplore.ieee.org/document/6595831/},
	doi = {10.1109/CSF.2013.22},
	eventtitle = {2013 {IEEE} 26th Computer Security Foundations Symposium ({CSF})},
	pages = {224--239},
	booktitle = {2013 {IEEE} 26th Computer Security Foundations Symposium},
	publisher = {{IEEE}},
	author = {Fennell, Luminous and Thiemann, Peter},
	urldate = {2025-02-10},
	date = {2013-06},
	year = {2013},
}

@article{toro_type-driven_2018,
	title = {Type-Driven Gradual Security with References},
	volume = {40},
	issn = {0164-0925, 1558-4593},
	url = {https://dl.acm.org/doi/10.1145/3229061},
	doi = {10.1145/3229061},
	abstract = {In security-typed programming languages, types statically enforce noninterference between potentially conspiring values, such as the arguments and results of functions. But to adopt static security types, like other advanced type disciplines, programmers face a steep wholesale transition, often forcing them to refactor working code just to satisfy their type checker. To provide a gentler path to security typing that supports safe and stylish but hard-to-verify programming idioms, researchers have designed languages that blend static and dynamic checking of security types. Unfortunately, most of the resulting languages only support static, type-based reasoning about noninterference if a program is entirely statically secured. This limitation substantially weakens the benefits that dynamic enforcement brings to static security typing. Additionally, current proposals are focused on languages with explicit casts and therefore do not fulfill the vision of gradual typing, according to which the boundaries between static and dynamic checking only arise from the (im)precision of type annotations and are transparently mediated by implicit checks.

              In this article, we present {GSL}
              Ref
              , a gradual security-typed higher-order language with references. As a gradual language, {GSL}
              Ref
              supports the range of static-to-dynamic security checking exclusively driven by type annotations, without resorting to explicit casts. Additionally, {GSL}
              Ref
              lets programmers use types to reason statically about termination-insensitive noninterference in
              all
              programs, even those that enforce security dynamically. We prove that {GSL}
              Ref
              satisfies all but one of Siek et al.’s criteria for gradually-typed languages, which ensure that programs can seamlessly transition between simple typing and security typing. A notable exception regards the dynamic gradual guarantee, which some specific programs must violate if they are to satisfy noninterference; it remains an open question whether such a language could fully satisfy the dynamic gradual guarantee. To realize this design, we were led to draw a sharp distinction between syntactic type
              safety
              and semantic type
              soundness
              , each of which constrains the design of the gradual language.},
	pages = {1--55},
	number = {4},
	journaltitle = {{ACM} Transactions on Programming Languages and Systems},
	journal = {{ACM} Transactions on Programming Languages and Systems},
	shortjournal = {{ACM} Trans. Program. Lang. Syst.},
	author = {Toro, Matías and Garcia, Ronald and Tanter, \'Eric},
	urldate = {2025-02-10},
	date = {2018-12-31},
	year = {2018},
	langid = {english},
	keywords = {Gradual Typing},
	file = {Toro et al. - 2018 - Type-Driven Gradual Security with References.pdf:/home/celebrimbor/Zotero/storage/VQHKRUG8/Toro et al. - 2018 - Type-Driven Gradual Security with References.pdf:application/pdf},
}

@article{chen_quest_2024,
	title = {Quest Complete: The Holy Grail of Gradual Security},
	volume = {8},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3656442},
	doi = {10.1145/3656442},
	shorttitle = {Quest Complete},
	abstract = {Languages with gradual information-flow control combine static and dynamic techniques to prevent security leaks. Gradual languages should satisfy the gradual guarantee: programs that only differ in the precision of their type annotations should behave the same modulo cast errors. Unfortunately, Toro et al. [2018] identify a tension between the gradual guarantee and information security; they were unable to satisfy both properties in the language {GSLRef} and had to settle for only satisfying information-flow security. Azevedo de Amorim et al. [2020] show that by sacrificing type-guided classification, one obtains a language that satisfies both noninterference and the gradual guarantee. Bichhawat et al. [2021] show that both properties can be satisfied by sacrificing the no-sensitive-upgrade mechanism, replacing it with a static analysis.

In this paper we present a language design, 𝜆★{IFC}, that satisfies both noninterference and the gradual guarantee without making any sacrifices. We keep the type-guided classification of {GSLRef} and use the standard no-sensitive-upgrade mechanism to prevent implicit flows through mutable references. The key to the design of 𝜆★{IFC} is to walk back the decision in {GSLRef} to include the unknown label ★ among the runtime security labels. We give a formal definition of 𝜆★{IFC}, prove the gradual guarantee, and prove noninterference. Of technical note, the semantics of 𝜆★{IFC} is the first gradual information-flow control language to be specified using coercion calculi (a la Henglein), thereby expanding the coercion-based theory of gradual typing.},
	pages = {1609--1632},
	issue = {{PLDI}},
	journaltitle = {Proceedings of the {ACM} on Programming Languages},
	journal = {Proceedings of the {ACM} on Programming Languages},
	shortjournal = {Proc. {ACM} Program. Lang.},
	author = {Chen, Tianyu and Siek, Jeremy G.},
	urldate = {2025-02-10},
	date = {2024-06-20},
	year = {2024},
	langid = {english},
	file = {Chen and Siek - 2024 - Quest Complete The Holy Grail of Gradual Security.pdf:/home/celebrimbor/Zotero/storage/MXVRX6MS/Chen and Siek - 2024 - Quest Complete The Holy Grail of Gradual Security.pdf:application/pdf},
}

@article{igarashi_gradual_2017,
	title = {Gradual session types},
	volume = {1},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3110282},
	doi = {10.1145/3110282},
	abstract = {Session types are a rich type discipline, based on linear types, that lift the sort of safety claims that come with type systems to communications. However, web-based applications and micro services are often written in a mix of languages, with type disciplines in a spectrum between static and dynamic typing. Gradual session types address this mixed setting by providing a framework which grants seamless transition between statically typed handling of sessions and any required degree of dynamic typing.
            We propose {GradualGV} as an extension of the functional session type system {GV} with dynamic types and casts. We demonstrate type and communication safety as well as blame safety, thus extending previous results to functional languages with session-based communication. The interplay of linearity and dynamic types requires a novel approach to specifying the dynamics of the language.},
	pages = {1--28},
	issue = {{ICFP}},
	journaltitle = {Proceedings of the {ACM} on Programming Languages},
	journal = {Proceedings of the {ACM} on Programming Languages},
	shortjournal = {Proc. {ACM} Program. Lang.},
	author = {Igarashi, Atsushi and Thiemann, Peter and Vasconcelos, Vasco T. and Wadler, Philip},
	urldate = {2025-02-10},
	date = {2017-08-29},
	year = {2017},
	langid = {english},
	keywords = {Gradual Typing},
	file = {Full Text:/home/celebrimbor/Zotero/storage/S5WFYW53/Igarashi et al. - 2017 - Gradual session types.pdf:application/pdf},
}
@book{martin-lof_intuitionistic_1984,
	Author = {Martin-L{\"o}f, Per},
	Isbn = {88-7088-105-9},
	Mrclass = {03B15 (03F50 03F55)},
	Mrnumber = {769301 (86j:03005)},
	Mrreviewer = {M. M. Richter},
	Pages = {iv+91},
	Publisher = {Bibliopolis},
	Series = {Studies in Proof Theory},
	Subtitle = {Notes by Giovanni Sambin},
	Title = {Intuitionistic type theory},
	Volume = {1},
	Year = {1984}}

@article{coquand_calculus_1988,
	title = {The calculus of constructions},
	volume = {76},
	rights = {https://www.elsevier.com/tdm/userlicense/1.0/},
	issn = {08905401},
	url = {https://linkinghub.elsevier.com/retrieve/pii/0890540188900053},
	doi = {10.1016/0890-5401(88)90005-3},
	pages = {95--120},
	number = {2},
	journaltitle = {Information and Computation},
	journal = {Information and Computation},
	shortjournal = {Information and Computation},
	author = {Coquand, Thierry and Huet, Gérard},
	urldate = {2025-02-10},
	date = {1988-02},
	year = {1988},
	langid = {english},
	keywords = {Dependent Types},
}

@article{siek_refined_2015,
	title = {Refined Criteria for Gradual Typing},
	volume = {32},
	rights = {Creative Commons Attribution 3.0 Unported license, info:eu-repo/semantics/{openAccess}},
	issn = {1868-8969},
	url = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.SNAPL.2015.274},
	doi = {10.4230/LIPICS.SNAPL.2015.274},
	abstract = {Siek and Taha [2006] coined the term gradual typing to describe a theory for integrating static and dynamic typing within a single language that 1) puts the programmer in control of which regions of code are statically or dynamically typed and 2) enables the gradual evolution of code between the two typing disciplines. Since 2006, the term gradual typing has become quite popular but its meaning has become diluted to encompass anything related to the integration of static and dynamic typing. This dilution is partly the fault of the original paper, which provided an incomplete formal characterization of what it means to be gradually typed. In this paper we draw a crisp line in the sand that includes a new formal property, named the gradual guarantee, that relates the behavior of programs that differ only with respect to their type annotations.  We argue that the gradual guarantee provides important guidance for designers of gradually typed languages. We survey the gradual typing literature, critiquing designs in light of the gradual guarantee. We also report on a mechanized proof that the gradual guarantee holds for the Gradually Typed Lambda Calculus.},
	pages = {274--293},
	journaltitle = {{LIPIcs}, Volume 32, {SNAPL} 2015},
	journal = {{LIPIcs}, Volume 32, {SNAPL} 2015},
	author = {Siek, Jeremy G. and Vitousek, Michael M. and Cimini, Matteo and Boyland, John Tang},
	editora = {Ball, Thomas and Bodik, Rastislav and Krishnamurthi, Shriram and Lerner, Benjamin S. and Morrisett, Greg},
	editoratype = {collaborator},
	urldate = {2024-09-04},
	date = {2015},
	year = {2015},
	langid = {english},
	keywords = {Gradual Typing},
	file = {LIPIcs.SNAPL.2015.274.pdf:/home/celebrimbor/Zotero/storage/H8AKIMZA/LIPIcs.SNAPL.2015.274.pdf:application/pdf},
}

@article{new_graduality_2018,
	title = {Graduality from embedding-projection pairs},
	volume = {2},
	url = {https://dl.acm.org/doi/10.1145/3236768},
	doi = {10.1145/3236768},
	abstract = {Gradually typed languages allow statically typed and dynamically typed code to interact while maintaining benefits of both styles. The key to reasoning about these mixed programs is Siek-Vitousek-Cimini-Boyland’s (dynamic) gradual guarantee, which says that giving components of a program more precise types only adds runtime type checking, and does not otherwise change behavior. In this paper, we give a semantic reformulation of the gradual guarantee called graduality. We change the name to promote the analogy that graduality is to gradual typing what parametricity is to polymorphism. Each gives a local-to-global, syntactic-to-semantic reasoning principle that is formulated in terms of a kind of observational approximation. Utilizing the analogy, we develop a novel logical relation for proving graduality. We show that embedding-projection pairs (ep pairs) are to graduality what relations are to parametricity. We argue that casts between two types where one is “more dynamic” (less precise) than the other necessarily form an ep pair, and we use this to cleanly prove the graduality cases for casts from the ep-pair property. To construct ep pairs, we give an analysis of the type dynamism relation—also known as type precision or naïve subtyping—that interprets the rules for type dynamism as compositional constructions on ep pairs, analogous to the coercion interpretation of subtyping.},
	pages = {73:1--73:30},
	issue = {{ICFP}},
	journaltitle = {Proc. {ACM} Program. Lang.},
	journal = {Proc. {ACM} Program. Lang.},
	author = {New, Max S. and Ahmed, Amal},
	urldate = {2024-09-18},
	date = {2018-07-30},
	year = {2018},
	keywords = {Gradual Typing},
	file = {Full Text PDF:/home/celebrimbor/Zotero/storage/E3CBRIIF/New and Ahmed - 2018 - Graduality from embedding-projection pairs.pdf:application/pdf},
}

@incollection{siek_exploring_2009,
	location = {Berlin, Heidelberg},
	title = {Exploring the Design Space of Higher-Order Casts},
	volume = {5502},
	rights = {http://www.springer.com/tdm},
	isbn = {978-3-642-00589-3 978-3-642-00590-9},
	url = {http://link.springer.com/10.1007/978-3-642-00590-9_2},
	pages = {17--31},
	booktitle = {Programming Languages and Systems},
	publisher = {Springer Berlin Heidelberg},
	author = {Siek, Jeremy and Garcia, Ronald and Taha, Walid},
	editor = {Castagna, Giuseppe},
	urldate = {2025-02-11},
	date = {2009},
	year = {2009},
	doi = {10.1007/978-3-642-00590-9_2},
	note = {Series Title: Lecture Notes in Computer Science},
	file = {Full Text:/home/celebrimbor/Zotero/storage/7RK66QXF/Siek et al. - 2009 - Exploring the Design Space of Higher-Order Casts.pdf:application/pdf},
}

@inproceedings{garcia_abstracting_2016,
	location = {St. Petersburg {FL} {USA}},
	title = {Abstracting gradual typing},
	booktitle = {Abstracting gradual typing},
	isbn = {978-1-4503-3549-2},
	url = {https://dl.acm.org/doi/10.1145/2837614.2837670},
	doi = {10.1145/2837614.2837670},
	eventtitle = {{POPL} '16: The 43rd Annual {ACM} {SIGPLAN}-{SIGACT} Symposium on Principles of Programming Languages},
	pages = {429--442},
	publisher = {{ACM}},
	author = {Garcia, Ronald and Clark, Alison M. and Tanter, \'Eric},
	urldate = {2024-09-03},
	date = {2016-01-11},
	year = {2016},
	langid = {english},
	keywords = {Gradual Typing},
	file = {abstracting-gradual-typing .pdf:/home/celebrimbor/Zotero/storage/VSJNRPUS/abstracting-gradual-typing .pdf:application/pdf},
}

@incollection{pedrot_failure_2018,
	location = {Cham},
	title = {Failure is Not an Option},
	volume = {10801},
	isbn = {978-3-319-89883-4 978-3-319-89884-1},
	url = {http://link.springer.com/10.1007/978-3-319-89884-1_9},
	pages = {245--271},
	booktitle = {Programming Languages and Systems},
	publisher = {Springer International Publishing},
	author = {P\'edrot, Pierre-Marie and Tabareau, Nicolas},
	editor = {Ahmed, Amal},
	urldate = {2025-02-25},
	date = {2018},
	year = {2018},
	doi = {10.1007/978-3-319-89884-1_9},
	note = {Series Title: Lecture Notes in Computer Science},
	file = {Full Text:/home/celebrimbor/Zotero/storage/3JMUUIJK/Pédrot and Tabareau - 2018 - Failure is Not an Option.pdf:application/pdf},
}

@article{harper_type_1991,
	title = {Type checking with universes},
	volume = {89},
	rights = {https://www.elsevier.com/tdm/userlicense/1.0/},
	issn = {03043975},
	url = {https://linkinghub.elsevier.com/retrieve/pii/030439759090108T},
	doi = {10.1016/0304-3975(90)90108-T},
	pages = {107--136},
	number = {1},
	journaltitle = {Theoretical Computer Science},
	journal = {Theoretical Computer Science},
	shortjournal = {Theoretical Computer Science},
	author = {Harper, Robert and Pollack, Robert},
	urldate = {2025-03-03},
	date = {1991-10},
	year = {1991},
	langid = {english},
}

@article{chargueraud_locally_2012,
	title = {The Locally Nameless Representation},
	volume = {49},
	rights = {http://www.springer.com/tdm},
	issn = {0168-7433, 1573-0670},
	url = {http://link.springer.com/10.1007/s10817-011-9225-2},
	doi = {10.1007/s10817-011-9225-2},
	pages = {363--408},
	number = {3},
	journaltitle = {Journal of Automated Reasoning},
	journal = {Journal of Automated Reasoning},
	shortjournal = {J Autom Reasoning},
	author = {Charguéraud, Arthur},
	urldate = {2025-03-03},
	date = {2012-10},
	year = {2012},
	langid = {english},
	file = {Full Text:/home/celebrimbor/Zotero/storage/GQZB3YD5/Charguéraud - 2012 - The Locally Nameless Representation.pdf:application/pdf},
}

@article{danvy_refocusing_2004,
	title = {Refocusing in Reduction Semantics},
	volume = {11},
	issn = {1601-5355, 0909-0878},
	url = {https://tidsskrift.dk/brics/article/view/21851},
	doi = {10.7146/brics.v11i26.21851},
	abstract = {The evaluation function of a reduction semantics (i.e., a small-step operational semantics with an explicit representation of the reduction context) is canonically deﬁned as the transitive closure of (1) decomposing a term into a reduction context and a redex, (2) contracting this redex, and (3) plugging the contractum in the context. Directly implementing this evaluation function therefore yields an interpreter with a worst-case overhead, for each step, that is linear in the size of the input term.},
	number = {26},
	journaltitle = {{BRICS} Report Series},
	journal = {{BRICS} Report Series},
	shortjournal = {{BRICS}},
	author = {Danvy, Olivier and Nielsen, Lasse R.},
	urldate = {2025-01-27},
	date = {2004-11-11},
	year = {2004},
	langid = {english},
	file = {Danvy and Nielsen - 2004 - Refocusing in Reduction Semantics.pdf:/home/celebrimbor/Zotero/storage/ZFL2KNFU/Danvy and Nielsen - 2004 - Refocusing in Reduction Semantics.pdf:application/pdf},
}

@inproceedings{gregoire_compiled_2002,
	location = {Pittsburgh {PA} {USA}},
	title = {A compiled implementation of strong reduction},
	isbn = {978-1-58113-487-2},
	url = {https://dl.acm.org/doi/10.1145/581478.581501},
	doi = {10.1145/581478.581501},
	eventtitle = {{ICFP}02: International Conference on Functional Programming},
	pages = {235--246},
	booktitle = {Proceedings of the seventh {ACM} {SIGPLAN} international conference on Functional programming},
	publisher = {{ACM}},
	author = {Gr\'egoire, Benjamin and Leroy, Xavier},
	urldate = {2025-05-06},
	date = {2002-09-17},
	year = {2002},
	langid = {english},
	file = {Full Text:/home/celebrimbor/Zotero/storage/E97YCXYZ/Grégoire and Leroy - 2002 - A compiled implementation of strong reduction.pdf:application/pdf},
}

@inproceedings{gimenez_structural_1998,
	location = {Berlin, Heidelberg},
	title = {Structural recursive definitions in type theory},
	isbn = {978-3-540-68681-1},
	abstract = {We introduce an extension of the Calculus of Construction with inductive and co-inductive types that preserves normalisation, while keeping a relatively simple collection of typing rules. This extension considerably enlarges the expressiveness of the language, enabling a direct representation of recursive programs in type theory.},
	pages = {397--408},
	booktitle = {Automata, Languages and Programming},
	publisher = {Springer Berlin Heidelberg},
	author = {Gim\'enez, Eduardo},
	editor = {Larsen, Kim G. and Skyum, Sven and Winskel, Glynn},
	date = {1998},
	year = {1998},
}

@phdthesis{lennon-bertrand_bidirectional_2022,
	title = {Bidirectional Typing for the Calculus of Inductive Constructions},
	url = {https://www.meven.ac/category/phd-thesis.html},
	author = {Lennon-Bertrand, Meven},
	abstract = {Over their more than 50 years of existence, proof assistants have established themselves as tools guaranteeing high trust levels in many applications. Yet, due to their increasing complexity, the historical solution of relying on a small, trusted kernel is not enough anymore to avoid critical bugs while moving forward. But proof assistants have been used for decades to certify program correctness, so why not their own? This is the ambition of the {MetaCoq} project, which aims at providing the first realistic kernel for a proof assistant – Coq – to be formally proven correct, in Coq itself. Don't trust the program anymore, only its proof!
This thesis studies the bidirectional structure on which the typing algorithm implemented by the kernel of Coq relies, in the context of the Calculus of Inductive Constructions on which it is founded. This is formalized as a part of {MetaCoq}, and is a key step to reach the project’s goal, by giving an intermediate layer between the implementation and its specification. Moreover, the increased control over computation offered by bidirectional typing is a necessary piece in designing a gradual extension of {CIC}, which aims at bringing to development in Coq the flexibility of dynamic typing, and forms the last part of the thesis.},
	institution = {University of Nantes},
	school = {University of Nantes},
	type = {phdthesis},
	keywords = {Dependent Types, Gradual Typing},
	year = {2022},
	file = {22-phd.pdf:/home/celebrimbor/Zotero/storage/K5YYCP49/22-phd.pdf:application/pdf},
}

@inproceedings{felleisen_control_1987,
    title = {Control operators, the {SED}-machine, and the \(\lambda\)-calculus},
    isbn = {978-0-444-70253-1},
    url = {https://legacy.cs.indiana.edu/ftp/techreports/TR197.pdf},
    booktitle = {Formal {Description} of {Programming} {Concepts} {III}},
    publisher = {North-Holland},
    author = {Felleisen, Matthias and Friedman, D.P.},
    editor = {Wirsing, Martin},
    year = {1987},
}

@article{siek_blame_2021,
	title = {Blame and coercion: Together again for the first time},
	volume = {31},
	issn = {0956-7968, 1469-7653},
	url = {https://www.cambridge.org/core/product/identifier/S0956796821000101/type/journal_article},
	doi = {10.1017/S0956796821000101},
	shorttitle = {Blame and coercion},
	abstract = {Abstract

              C\#, Dart, Pyret, Racket, {TypeScript}, {VB}: many recent languages integrate dynamic and static types via gradual typing. We systematically develop four calculi for gradual typing and the relations between them, building on and strengthening previous work. The calculi are as follows:



                  \${\textbackslash}lambda\{B\}\$


              , based on the blame calculus of Wadler and Findler (2009);



                  \${\textbackslash}lambda\{C\}\$


              , inspired by the coercion calculus of Henglein (1994);



                  \${\textbackslash}lambda\{S\}\$


              inspired by the space-efficient calculus of Herman, Tomb, and Flanagan (2006); and



                  \${\textbackslash}lambda\{T\}\$


              based on the threesome calculus of Siek and Wadler (2010). While



                  \${\textbackslash}lambda\{B\}\$


              and



                  \${\textbackslash}lambda\{T\}\$


              are little changed from previous work,



                  \${\textbackslash}lambda\{C\}\$


              and



                  \${\textbackslash}lambda\{S\}\$


              are new. Together,



                  \${\textbackslash}lambda\{B\}\$


              ,



                  \${\textbackslash}lambda\{C\}\$


              ,



                  \${\textbackslash}lambda\{S\}\$


              , and



                  \${\textbackslash}lambda\{T\}\$


              provide a coherent foundation for design, implementation, and optimization of gradual types. We define translations from



                  \${\textbackslash}lambda\{B\}\$


              to



                  \${\textbackslash}lambda\{C\}\$


              , from



                  \${\textbackslash}lambda\{C\}\$


              to



                  \${\textbackslash}lambda\{S\}\$


              , and from



                  \${\textbackslash}lambda\{S\}\$


              to



                  \${\textbackslash}lambda\{T\}\$


              . Much previous work lacked proofs of correctness or had weak correctness criteria; here we demonstrate the strongest correctness criterion one could hope for, that each of the translations is fully abstract. Each of the calculi reinforces the design of the others:



                  \${\textbackslash}lambda\{C\}\$


              has a particularly simple definition, and the subtle definition of blame safety for



                  \${\textbackslash}lambda\{B\}\$


              is justified by the simple definition of blame safety for



                  \${\textbackslash}lambda\{C\}\$


              . Our calculus



                  \${\textbackslash}lambda\{S\}\$


              is implementation-ready: the first space-efficient calculus that is both straightforward to implement and easy to understand. We give two applications: first, using full abstraction from



                  \${\textbackslash}lambda\{C\}\$


              to



                  \${\textbackslash}lambda\{S\}\$


              to establish an equational theory of coercions; and second, using full abstraction from



                  \${\textbackslash}lambda\{B\}\$


              to



                  \${\textbackslash}lambda\{S\}\$


              to easily establish the Fundamental Property of Casts, which required a custom bisimulation and six lemmas in earlier work.},
	pages = {e20},
	journaltitle = {Journal of Functional Programming},
	journal = {Journal of Functional Programming},
	shortjournal = {J. Funct. Prog.},
	author = {Siek, Jeremy G. and Thiemann, Peter and Wadler, Philip},
	urldate = {2024-11-06},
	date = {2021},
	year = {2021},
	langid = {english},
	keywords = {Gradual Typing},
	file = {Full Text:/home/celebrimbor/Zotero/storage/CWMJIZAI/Siek et al. - 2021 - Blame and coercion Together again for the first t.pdf:application/pdf},
}

@article{dimoulas_correct_2011,
	title = {Correct blame for contracts: no more scapegoating},
	volume = {46},
	issn = {0362-1340, 1558-1160},
	url = {https://dl.acm.org/doi/10.1145/1925844.1926410},
	doi = {10.1145/1925844.1926410},
	shorttitle = {Correct blame for contracts},
	abstract = {Behavioral software contracts supplement interface information with logical assertions. A rigorous enforcement of contracts provides useful feedback to developers if it signals contract violations as soon as they occur and if it assigns blame to violators with preciseexplanations. Correct blame assignment gets programmers started with the debugging process and can significantly decrease the time needed to discover and fix bugs.
            Sadly the literature on contracts lacks a framework for making statements about the correctness of blame assignment and for validating such statements. This paper fills the gap and uses the framework to demonstrate how one of the proposed semantics for higher-order contracts satisfies this criteria and another semantics occasionally assigns blame to the wrong module.

              Concretely, the paper applies the framework to the
              lax
              enforcement of dependent higher-order contracts and the
              picky
              one. A higher-order dependent contract specifies constraints for the domain and range of higher-order functions and also relates arguments and results in auxiliary assertions. The picky semantics ensures that the use of arguments in the auxiliary assertion satisfies the domain contracts and the lax one does not. While the picky semantics discovers more contract violations than the lax one, it occasionally blames the wrong module. Hence the paper also introduces a third semantics, dubbed
              indy
              , which fixes the problems of the picky semantics without giving up its advantages.},
	pages = {215--226},
	number = {1},
	journaltitle = {{ACM} {SIGPLAN} Notices},
	journal = {{ACM} {SIGPLAN} Notices},
	shortjournal = {{SIGPLAN} Not.},
	author = {Dimoulas, Christos and Findler, Robert Bruce and Flanagan, Cormac and Felleisen, Matthias},
	urldate = {2025-06-16},
	date = {2011-01-26},
	year = {2011},
	langid = {english},
}

@inproceedings{siek_gradual_2008,
	location = {Paphos Cyprus},
	title = {Gradual typing with unification-based inference},
	isbn = {978-1-60558-270-2},
	url = {https://dl.acm.org/doi/10.1145/1408681.1408688},
	doi = {10.1145/1408681.1408688},
	eventtitle = {{DLS} '08: Dynamic Languages Symposium 2008},
	pages = {1--12},
	booktitle = {Proceedings of the 2008 symposium on Dynamic languages},
	publisher = {{ACM}},
	author = {Siek, Jeremy G. and Vachharajani, Manish},
	urldate = {2025-06-16},
	date = {2008-07-08},
	year = {2008},
	langid = {english},
}

@incollection{wadler_well-typed_2009,
	location = {Berlin, Heidelberg},
	title = {Well-Typed Programs Can’t Be Blamed},
	volume = {5502},
	rights = {http://www.springer.com/tdm},
	isbn = {978-3-642-00589-3 978-3-642-00590-9},
	url = {http://link.springer.com/10.1007/978-3-642-00590-9_1},
	pages = {1--16},
	booktitle = {Programming Languages and Systems},
	publisher = {Springer Berlin Heidelberg},
	author = {Wadler, Philip and Findler, Robert Bruce},
	editor = {Castagna, Giuseppe},
	urldate = {2025-08-05},
	date = {2009},
	year = {2009},
	doi = {10.1007/978-3-642-00590-9_1},
	note = {Series Title: Lecture Notes in Computer Science},
	file = {Full Text:/home/celebrimbor/Zotero/storage/AA5JM8W2/Wadler and Findler - 2009 - Well-Typed Programs Can’t Be Blamed.pdf:application/pdf},
}

@incollection{brady_inductive_2004,
	location = {Berlin, Heidelberg},
	title = {Inductive Families Need Not Store Their Indices},
	volume = {3085},
	isbn = {978-3-540-22164-7 978-3-540-24849-1},
	url = {http://link.springer.com/10.1007/978-3-540-24849-1_8},
	pages = {115--129},
	booktitle = {Types for Proofs and Programs},
	publisher = {Springer Berlin Heidelberg},
	author = {Brady, Edwin and {McBride}, Conor and {McKinna}, James},
	editor = {Berardi, Stefano and Coppo, Mario and Damiani, Ferruccio},
	editorb = {Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Dough and Vardi, Moshe Y. and Weikum, Gerhard},
	editorbtype = {redactor},
	urldate = {2025-08-05},
	date = {2004},
	year = {2004},
	doi = {10.1007/978-3-540-24849-1_8},
	note = {Series Title: Lecture Notes in Computer Science},
}

@article{abel_decidability_2018,
	title = {Decidability of conversion for type theory in type theory},
	volume = {2},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3158111},
	doi = {10.1145/3158111},
	abstract = {Type theory should be able to handle its own meta-theory, both to justify its foundational claims and to obtain a verified implementation. At the core of a type checker for intensional type theory lies an algorithm to check equality of types, or in other words, to check whether two types are convertible. We have formalized in Agda a practical conversion checking algorithm for a dependent type theory with one universe à la Russell, natural numbers, and η-equality for Π types. We prove the algorithm correct via a Kripke logical relation parameterized by a suitable notion of equivalence of terms. We then instantiate the parameterized fundamental lemma twice: once to obtain canonicity and injectivity of type formers, and once again to prove the completeness of the algorithm. Our proof relies on inductive-recursive definitions, but not on the uniqueness of identity proofs. Thus, it is valid in variants of intensional Martin-Löf Type Theory as long as they support induction-recursion, for instance, Extensional, Observational, or Homotopy Type Theory.},
	pages = {1--29},
	issue = {{POPL}},
	journaltitle = {Proceedings of the {ACM} on Programming Languages},
	journal = {Proceedings of the {ACM} on Programming Languages},
	shortjournal = {Proc. {ACM} Program. Lang.},
	author = {Abel, Andreas and Öhman, Joakim and Vezzosi, Andrea},
	urldate = {2025-08-05},
	date = {2018-01},
	year = {2018},
	langid = {english},
	file = {Full Text:/home/celebrimbor/Zotero/storage/XQLINB3H/Abel et al. - 2018 - Decidability of conversion for type theory in type.pdf:application/pdf},
}

@article{sozeau_coq_2020,
	title = {Coq Coq correct! verification of type checking and erasure for Coq, in Coq},
	volume = {4},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3371076},
	doi = {10.1145/3371076},
	abstract = {Coq is built around a well-delimited kernel that perfoms typechecking for definitions in a variant of the Calculus of Inductive Constructions ({CIC}). Although the metatheory of {CIC} is very stable and reliable, the correctness of its implementation in Coq is less clear. Indeed, implementing an efficient type checker for {CIC} is a rather complex task, and many parts of the code rely on implicit invariants which can easily be broken by further evolution of the code. Therefore, on average, one critical bug has been found every year in Coq.
            This paper presents the first implementation of a type checker for the kernel of Coq (without the module system and template polymorphism), which is proven correct in Coq with respect to its formal specification and axiomatisation of part of its metatheory. Note that because of Gödel's incompleteness theorem, there is no hope to prove completely the correctness of the specification of Coq inside Coq (in particular strong normalisation or canonicity), but it is possible to prove the correctness of the implementation assuming the correctness of the specification, thus moving from a trusted code base ({TCB}) to a trusted theory base ({TTB}) paradigm.
            Our work is based on the {MetaCoq} project which provides metaprogramming facilities to work with terms and declarations at the level of this kernel. Our type checker is based on the specification of the typing relation of the Polymorphic, Cumulative Calculus of Inductive Constructions ({PCUIC}) at the basis of Coq and the verification of a relatively efficient and sound type-checker for it. In addition to the kernel implementation, an essential feature of Coq is the so-called extraction: the production of executable code in functional languages from Coq definitions. We present a verified version of this subtle type-and-proof erasure step, therefore enabling the verified extraction of a safe type-checker for Coq.},
	pages = {1--28},
	issue = {{POPL}},
	journaltitle = {Proceedings of the {ACM} on Programming Languages},
	shortjournal = {Proc. {ACM} Program. Lang.},
	author = {Sozeau, Matthieu and Boulier, Simon and Forster, Yannick and Tabareau, Nicolas and Winterhalter, Théo},
	urldate = {2025-08-05},
	date = {2020-01},
	year = {2020},
	langid = {english},
	file = {Full Text:/home/celebrimbor/Zotero/storage/99A2FDJM/Sozeau et al. - 2020 - Coq Coq correct! verification of type checking and.pdf:application/pdf},
}

@article{garcia_principal_2015,
	title = {Principal Type Schemes for Gradual Programs},
	volume = {50},
	issn = {0362-1340, 1558-1160},
	url = {https://dl.acm.org/doi/10.1145/2775051.2676992},
	doi = {10.1145/2775051.2676992},
	abstract = {Gradual typing is a discipline for integrating dynamic checking into a static type system. Since its introduction in functional languages, it has been adapted to a variety of type systems, including object-oriented, security, and substructural. This work studies its application to implicitly typed languages based on type inference. Siek and Vachharajani designed a gradual type inference system and algorithm that infers gradual types but still rejects ill-typed static programs. However, the type system requires local reasoning about type substitutions, an imperative inference algorithm, and a subtle correctness statement.
            This paper introduces a new approach to gradual type inference, driven by the principle that gradual inference should only produce static types. We present a static implicitly typed language, its gradual counterpart, and a type inference procedure. The gradual system types the same programs as Siek and Vachharajani, but has a modular structure amenable to extension. The language admits let-polymorphism, and its dynamics are defined by translation to the Polymorphic Blame Calculus.
            The principal types produced by our initial type system mask the distinction between static parametric polymorphism and polymorphism that can be attributed to gradual typing. To expose this difference, we distinguish static type parameters from gradual type parameters and reinterpret gradual type consistency accordingly. The resulting extension enables programs to be interpreted using either the polymorphic or monomorphic Blame Calculi.},
	pages = {303--315},
	number = {1},
	journaltitle = {{ACM} {SIGPLAN} Notices},
	journal = {{ACM} {SIGPLAN} Notices},
	shortjournal = {{SIGPLAN} Not.},
	author = {Garcia, Ronald and Cimini, Matteo},
	urldate = {2025-08-09},
	date = {2015-05-11},
	year = {2015},
	langid = {english},
	file = {Submitted Version:/home/celebrimbor/Zotero/storage/RLYCHPG9/Garcia and Cimini - 2015 - Principal Type Schemes for Gradual Programs.pdf:application/pdf},
}

@article{herman_space-efficient_2010,
	title = {Space-efficient gradual typing},
	volume = {23},
	rights = {http://www.springer.com/tdm},
	issn = {1388-3690, 1573-0557},
	url = {http://link.springer.com/10.1007/s10990-011-9066-z},
	doi = {10.1007/s10990-011-9066-z},
	pages = {167--189},
	number = {2},
	journaltitle = {Higher-Order and Symbolic Computation},
	journal = {Higher-Order and Symbolic Computation},
	shortjournal = {Higher-Order Symb Comput},
	author = {Herman, David and Tomb, Aaron and Flanagan, Cormac},
	urldate = {2024-11-15},
	date = {2010-06},
	year = {2010},
	langid = {english},
	keywords = {Gradual Typing},
	file = {Full Text:/home/celebrimbor/Zotero/storage/88TMD9CF/Herman et al. - 2010 - Space-efficient gradual typing.pdf:application/pdf},
}

@phdthesis{tejiscak_erasure_2020,
	title = {Erasure in dependently typed programming},
	doi = {10.17630/STA/677},
	abstract = {It is important to reduce the cost of correctness in programming. Dependent types and related techniques, such as type-driven programming, oﬀer ways to do so. Some parts of dependently typed programs constitute evidence of their typecorrectness and, once checked, are unnecessary for execution. These parts can easily become asymptotically larger than the remaining runtime-useful computation, which can cause linear-time algorithms run in exponential time, or worse. It would be unnacceptable, and contradict our goal of reducing the cost of correctness, to make programs run slower by only describing them more precisely. Current systems cannot erase such computation satisfactorily. By modelling erasure indirectly through type universes or irrelevance, they impose the limitations of these means to erasure. Some useless computation then cannot be erased and idiomatic programs remain asymptotically sub-optimal. This dissertation explains why we need erasure, that it is diﬀerent from other concepts like irrelevance, and proposes two ways of erasing non-computational data. One is an untyped ﬂow-based useless variable elimination, adapted for dependently typed languages, currently implemented in the Idris 1 compiler. The other is the main contribution of the dissertation: a dependently typed core calculus with erasure annotations, full dependent pattern matching, and an algorithm that infers erasure annotations from unannotated (or partially annotated) programs. I show that erasure in well-typed programs is sound in that it commutes with single-step reduction. Assuming the Church-Rosser property of reduction, I show that properties such as Subject Reduction hold, which extends the soundness result to multi-step reduction. I also show that the presented erasure inference is sound and complete with respect to the typing rules; that this approach can be extended with various forms of erasure polymorphism; that it works well with monadic I/O and foreign functions; and that it is eﬀective in that it not only removes the runtime overhead caused by dependent typing in the presented examples, but can also shorten compilation times.},
	author = {Tejiščák, Matúš},
	editora = {Brady, Edwin},
	editoratype = {collaborator},
	urldate = {2025-05-06},
	date = {2020-07-07},
	year = {2020},
	langid = {english},
	note = {Publisher: University of St Andrews},
	school = {University of St Andrews},
	keywords = {Dependent Types, Computer software--Verification, Functional programming (Computer science), Idris (Computer program language), {QA}76.62T4},
	file = {Tejiščák - 2020 - Erasure in dependently typed programming.pdf:/home/celebrimbor/Zotero/storage/J2IM9BR4/Tejiščák - 2020 - Erasure in dependently typed programming.pdf:application/pdf},
}
